secret:
  existingSecret: ""
  POSTGRES_DB: "odoo"
  POSTGRES_USER: "odoo"
  POSTGRES_PASSWORD: ""      # A random password will be generated if not given

postgres:
  enabled: true
  # externalHostName: "if you have a server, point at it here"
  name: "postgres"
  image:
    repository: postgres
    tag: "18.1"
  storage:
    data:
      enabled: true
      existingClaim: ""
      storageClass: null
      accessMode: ReadWriteOnce
      # mount path used inside the postgres container (kept for backwards-compat)
      path: "/var/lib/postgresql"
      size: 2Gi
    extraVolumes: []
    extraMounts: []
  service:
    enabled: true
    type: ClusterIP
    port: 5432
  # Default probes can be overridden by setting postgres.livenessProbe/readinessProbe in values.yaml
  livenessProbe: {}
  readinessProbe: {}

app:
  replicaCount: 1
  image:
    repository: ghcr.io/adomi-io/odoo
    tag: "19.0"
    pullPolicy: IfNotPresent
  setup:
    image:
      repository: postgres
      tag: "18.1"
      pullPolicy: IfNotPresent
  imagePullSecrets: []
  serviceAccountName: ""
  labels: {}
  podLabels: {}
  annotations: {}     # chart-level annotations (merged into resources)
  podAnnotations: {}
  service:
    # Flattened: use service.type and service.ports (was service.spec)
    type: ClusterIP
    ports:
      - name: webservice
        protocol: TCP
        port: 8069
        targetPort: 8069
      - name: polling
        protocol: TCP
        port: 8072
        targetPort: 8072
    annotations: {}   # per-service annotations
  storage:
    mounts:
      - name: data
        enabled: true
        accessMode: ReadWriteOnce
        path: "/volumes/data"
        size: 10Gi
  # Resources intentionally empty by default; set CPU/memory requests/limits as needed for your cluster.
  resources: {}
  # App-level probes. If empty, chart will use sensible defaults that read the first service port.
  livenessProbe: {}
  readinessProbe: {}
  affinity: {}
  nodeSelector: {}
  tolerations: []
